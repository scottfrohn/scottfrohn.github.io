---
title: "Simple IRT CAT"
author: 'Scott Frohn'
date: 'July 18, 2024'
bibliography: references.bib
output: 
  html_document: 
    number_sections: false
    toc: false
    fig_width: 7
    fig_height: 4.5
    theme: readable
    highlight: tango
    code_folding: show
---

# Introduction

Computerized adaptive testing (CAT) is a form of assessment that tailors the difficulty of test questions to the ability level of each individual test-taker in real-time. Unlike traditional fixed-form tests where all examinees receive the same set of questions, a CAT dynamically selects items from an item bank based on the test-taker's performance on previous items.

CAT is particularly useful because it offers several key advantages:

1.  Efficiency: CAT can estimate a test-taker's ability level with fewer items than traditional tests, potentially reducing testing time.
2.  Precision: By adapting to each individual's ability level, CAT can provide more accurate ability estimates across a wide range of proficiency levels.
3.  Security: Since different test-takers receive different sets of items, test security can be enhanced.
4.  Motivation: By presenting items that match the test-taker's ability, CAT can help maintain engagement and reduce frustration.

Generally, a CAT system works through the following steps:

1.  It starts with an initial estimate of the test-taker's ability level.
2.  Based on this estimate, it selects and administers an appropriate item from the item bank.
3.  After the test-taker responds, the system scores the response and updates the ability estimate.
4.  Using the new ability estimate, it selects the next most informative item.
5.  This process continues until a stopping criterion is met (e.g., reaching a certain level of measurement precision or a maximum number of items).

The effectiveness of CAT relies on a well-calibrated item bank, typically using Item Response Theory (IRT) models, and sophisticated algorithms for item selection and ability estimation. This project aims to demonstrate the basic principles and implementation of a CAT system, including item bank creation, ability estimation, item selection, and stopping rules.

Note that there are other R packages that are designed to facilitate computerized adaptive testing (e.g., [catR](https://cran.r-project.org/web/packages/catR/)), but for this project, I've built the package `CATFunctions` from scratch.

For futher reading on IRT and CAT, I'll recommend:

-   @deayala2022irt for a comprehensive and accessible overview of IRT, and
-   @magis2017cat for a detailed treatment of computerized adaptive testing, with examples in R.

## Prepare workspace

Load packages, including custom package `CATFunctions` to support this analysis.

```{r setup, message=FALSE}
# Load packages
library(psych)        # For descriptive stats
library(ggthemes)     # Additional ggplot themes
library(tidyverse)    # Keeps things tidy
library(CATFunctions) # devtools::install_github("scottfrohn/CATFunctions")
options(digits = 3)
```

# Overview of an IRT-Based CAT

Here are the steps for implementing an IRT-based CAT in detail:

1.  Calibrate the item bank.
2.  Select the first item(s).
3.  Deliver and record the item response.
4.  Score the response.
5.  Update response pattern.
6.  Estimate ability.
7.  Check stopping rule.

If the stopping rule is not satisfied:

8.  Identify the set of eligible items to select the next item.
9.  Select the next item from eligible items.
10. Circle back to Step '3' (Record the response) and repeat the process.

If the stopping rule is satisfied:

11. The test stops.
12. The final ability estimate is delivered.

Before creating and simulating a Simple CAT, here are a few notes on some (but not all) of the steps.

## Calibrating the item bank and scoring responses

Before we can run a computerized adaptive test, we require an item bank. For this demonstration, we will use an IRT-calibrated item bank for dichotomously scored items (responses are scored as 0 or 1). I created the function `generate_item_bank` for this purpose.

However, other item types and models can certainly be used in computer adaptive testing such as ordered polytomous items (items with multiple, ordered scoring levels). Those item types require different models that would need to be incorporated into the CAT, with item-type specific parameters (e.g., 'step' or 'threshold' parameters for the Partial Credit model), and adjustments to the item selection and estimation steps to account for items of different types. Currently, `generate_item_bank` only handles IRT item types (Rasch, 1pl, 2pl, and 3pl), and the custom scoring function `score_response` only performs dichotomous scoring.

## Selecting the first item.

The first step in a CAT is to determine which item(s) to deliver first. Here are a few options:

a.  Item with greatest information informative around the population mean.
b.  Item with difficulty closest to an initial ability level (Urry's rule).
c.  Using prior information (if available), and selecting item with most information close to the expected ability.
d.  Select a group of 2-3 items (using these or other methods)

However, for test security purposes we shouldn't select the same starting item for everyone. If we don't use prior information and everyone CAT begins at the same initial ability (e.g., ${\theta}_{0} = 0$), then it's very likely for an IRT-calibrated item bank that at that ability level, only one item would have the greatest information (option *a*) or closest difficulty (option *b*), and that same item would then be used to start every CAT. This is referred to as **initial item selection bias** or a **cold start problem**.

Therefore, if we don't have any prior information (which we'll assume for the purpose of this project), we'll need to introduce some variability into the initial item selection mechanism. For this project, we'll use option *b* with some variability baked-in to the initial item selection. The custom function `initial_item` uses this approach.

## Estimating ability

The method used to estimate ability can impact the precision and distribution of scores. Common methods are:

1.  Maximum Likelihood Estimation (MLE) - Selects the value of ${\theta}$ that maximizes the likelihood of the response string given the item parameters.
2.  Expected a posteriori (EAP) and Maximum a posteriori (MAP) - The value of ${\theta}$ is obtained using Bayesian approaches which sets a posterior distribution.
    a.  EAP is the mean of the posterior proficiency distribution for a given individual
    b.  MAP is the mode of the posterior proficiency distribution for a given individual

For this document, we'll use MLE to estimate ability after each item using the function `est_ability_mle`.

#### Notes on Maximum Likelihood

One drawback of MLE is that the likelihood function cannot be optimized for response patterns with zero variance (all 0's or all 1's), and this can become problematic at early stages in the CAT.

For instance, if someone gets the first item wrong, all we know is that their ability level is *probably* lower than the difficulty parameter of the first item (or thereabouts). A pure MLE estimate after the first item will probably be ***very*** low, and if we're basing item selection on the proximity of item difficulty to current ability, then the second item on the test will likely be one of the easiest item in the bank. If the respondent misses the first few items, their MLE ability estimate will be ***extremely*** low.

To demonstrate this, let's use the `CATFunctions` MLE estimation function `est_ability_mle` that uses the inputs:

1.  `responses` : a vector of item responses
2.  `as` : a vector of IRT discrimination `a` parameters
3.  `bs` : a vector of IRT discrimination `b` parameters
4.  `cs` : a vector of IRT discrimination `c` parameters

Let's imagine we answered the first item incorrectly (response = 0). Item parameters a, b, and c are 1, .5, and .1, respectively. Note in the syntax we set `est_ability_mle` argument `kludge = FALSE` for a pure ML estimate. More information on the `kludge` argument below.


```{r est_1}
est_ability_mle(0, 1, .5, .1, kludge = FALSE)$ability_est
```

An very low ability estimate (-4.09). If we base item selection on this estimate, the next item selected would be the easiest in the bank, perhaps in the neighborhood of -3 logits.

Let's say we somehow miss the second question too:

```{r est_1_nokludge}
est_ability_mle(
  c(0, 0),   # Response are 0 and 0
  c(1, 1),   # Both 'a' params are 1
  c(.5, -3), # Item 1 difficulty = 0.5, Item 2 difficulty = -3
  c(.1, .1),  # Both 'c' params are 0.1
  kludge = FALSE
)$ability_est
```

Again, the ability estimate is very low, and we'd witness similar extreme values if we got both items correct. Therefore, we need some way to adjust the MLE function so item selection early in the CAT isn't subject to wild swings in ability estimate. Let's look at the likelihood (or rather, Log-Likelihood) function which is optimized to identify the most likely value of ${\theta}$.

#### Log-Likelihood Function for the 3PL Model

The log-likelihood function for the 3-parameter logistic (3PL) model is given by:

$$
\log L(\theta) = \sum_{i=1}^{n} \left[ y_i \log P_i(\theta) + (1 - y_i) \log (1 - P_i(\theta)) \right]
$$

where:

-   $\theta$ is the ability parameter,

-   $y_i$ is the binary response (1 if correct, 0 if incorrect) to item $i$, and

-   $P_i(\theta)$ is the probability of a correct response to item $i$, which is defined as:

$$
P_i(\theta) = c_i + (1 - c_i) \frac{1}{1 + \exp(-a_i (\theta - b_i))}
$$

In this model:

-   $a_i$ is the discrimination parameter for item $i$,

-   $b_i$ is the difficulty parameter for item $i$, and

-   $c_i$ is the guessing parameter for item $i$.

The log-likelihood function incorporates these probabilities to estimate the ability parameter $\theta$ by maximizing the likelihood of observing the given responses.

#### Using an Adjustment Factor for MLE

One way we can adjust the maximum likelihood estimation is by using an adjustment factor, which adds (or subtracts) a small constant to all values of $y_i$ in response strings with zero variance when creating the likelihood function. Although our IRT model presumes binary responses of 0 or 1, the likelihood function will take any numerical value for $y_i$ (whether or not they make sense).

Therefore, by adjusting the response strings with no variance by a little bit, we can restrict our MLE ability estimates until we get some variability in responses.

To do this, the function `est_ability_mle` has a (default) `kludge` argument to employ an adjustment factor of $\frac{1}{3\sqrt{n}}$ to each item, where $n$ is the number of items in the response vector. For instance, the response vector `c(0,0,0,0)` would have an adjustment factor of $\frac{1}{3\sqrt{4}} = \frac{1}{6}$ and therefore the vector would become `c(0.167,0.167,0.167,0.167)`.

To demonstrate this method, let's estimate ability after each of the first 4 items of a CAT. For simplicity, we'll fix the a and c parameters for each run, and set the 'b' parameter for each item to be near the previous ability estimate.

```{r est2}
# First Item
est_ability_mle(0, 1, 0.5, .1)$ability_est
# [1] 0.5498125; let's set 'b' for Item 2 to .55

# Second item
est_ability_mle(rep(0,2), rep(1,2), c(0.5, .55), rep(.1, 2))$ability_est
# [1] -1.20393; let's set 'b' for Item 3 to -1.20

# Third Item
est_ability_mle(rep(0,3), rep(1,3), c(0.5, .55, -1.20), rep(.1, 3))$ability_est
# [1] -2.882119; let's set 'b' for Item 4 to -2.88

# Fourth Item
est_ability_mle(rep(0,4), rep(1,4), c(0.5, .55, -1.20, -2.88), rep(.1, 4))$ability_est
```

As we can see, this approach really restricts the ability estimates when we have no variability in response patterns. Once the test-taker provides a response that introduces variability (in this example, they answer the 5th item correct), then this adjustment factor is ignored and the MLE estimate is based solely on the actual response patterns. Let's see what happens if they get the next 3 items correct.

```{r est3}
est_ability_mle(c(0,0,0,0,1), rep(1,5), c(0.5, .55, -1.20, -2.88, -5.05), rep(.1, 5))$ability_est
est_ability_mle(c(0,0,0,0,1,1), rep(1,6), c(0.5, .55, -1.20, -2.88, -5.05, -4.24), rep(.1, 6))$ability_est
est_ability_mle(c(0,0,0,0,1,1,1), rep(1,7), c(0.5, .55, -1.20, -2.88, -5.05, -4.24, -3.57), rep(.1, 7))$ability_est
```

There we go, our estimates are coming back down to earth.

### The stopping rule

The stopping rule determines whether the CAT should end. There are four main stopping rules that are commonly considered:

1.  Length
    -   This sets the total number of items to be administered. Once this number is reached, the CAT terminates.
    -   This can ensure everyone sees the same \# of items (but at the cost of varying degrees of accuracy)
2.  Precision
    -   Stops the CAT when the ability level reaches a predefined level of precision (e.g., a provisional ability estimate has a standard error smaller than some pre-set criterion.)
    -   This has the benefit of efficiency, at the cost of different lengths of assessments.
3.  Classification
    -   Used for testing skill mastery.
    -   The main goal is to determine if the test taker has an ability greater or less than the level of mastery.
    -   In practice, this mastery level is set, and provisional confidence intervals are set around the provisional ability estimate. If the confidence level overlaps the mastery level, there's not enough certainty around classification and the test continues. If the provisional confidence level doesn't contain the mastery level, then a classification determination can be made confidently, and the test can terminate.
4.  Information
    -   Focus is the information carried by the remaining items in the item bank.
    -   The threshold is the minimum information carried by at least one of the eligible items. Condition for the CAT to continue is that remaining items have enough information to significantly increase the total information. If, at a provisional ability estimate, all eligible items have information values smaller than the threshold, the CAT stops.

For our demonstration, we'll use both length and precision as stopping criteria; we'll stop the test once (a) the standard error of our ability estimate falls below a pre-defined cutoff, otherwise the test will stop once it reaches a certain length (we want to limit the testing time). The function `stop_test` will evaulate against our set criteria.

### Selecting the next item from eligible items.

We have a few options for selecting subsequent items in a CAT. Here are a few options.

1.  **Maximum Fisher Information (MFI)**: Item with most *information* at the current ability estimate. $$ i_t^* = \arg \max_{i \in S_t} I_i(\hat{\theta}_{t-1}(X_{t-1})) $$

2.  **bOpt Criterion**, or **Urry's Rule**: Item with the *difficulty* nearest the current ability estimate. $$ i_t^* = \arg \min_{i \in S_t} \left| \hat{\theta}_{t-1}(X_{t-1}) - b_i \right| $$ - Note this will be the same as MFI for Rasch and 2PL models

3.  **Maximum Likelihood Weighted Information (MLWI)**: Weights the information by the likelihood function of the currently administered response pattern. Addresses the issue of MFI being severely biased in early stages of the CAT. $$ i_t^* = \arg \max_{i \in S_t} \int_{-\infty}^{+\infty} L(\theta | X_{t-1}) I_i(\theta) \, d\theta $$

4.  **Maximum Posterior Weighted Information (MPWI)** $$ i_t^* = \arg \max_{i \in S_t} \int_{-\infty}^{+\infty} f(\theta) L(\theta | X_{t-1}) I_i(\theta) \, d\theta $$

**Legend of Terms:**

-   $i_t^*$: Selected item at step $t$

-   $S_t$: Set of eligible items at step $t$

-   $I_i(\theta)$: Item information function for item $i$

-   $\hat{\theta}_{t-1}(X_{t-1})$: Current provisional ability estimate based on the current response pattern $X_{t-1}$

-   $b_i$: Difficulty level of item $i$

-   $L(\theta | X_{t-1})$: Likelihood function given response pattern $X_{t-1}$

-   $f(\theta)$: Prior distribution of ability (e.g., standard normal distribution)

There are many other selection methods we could use as well. For our purpose, let's just select the easiest one to implement now: **bOpt Criterion**, since the only values needed are the current ability estimate ($\hat{\theta}_{t-1}(X_{t-1})$) and eligible item locations ($b_i$). The list of eligible items are updated by the function `update_eligible_items`, and the `next_item` function handles the items selection.

# Basic CAT, Step-By-Step

Now that we have an overview of how an IRT-based CAT works, let's summarize some of the decisions we've noted for this current simulation.

## Structure

1.  Item Bank.
    -   Our simulated item bank will include IRT-calibrated parameters for dichotomously scored items.
2.  Initial Step.
    -   Without prior information (or making assumptions there), we'll use Urry's Rule and start selecting items with a difficulty near a current ability estimate (which we'll set to 0).
    -   To avoid over exposure of the item with $b$ closest to 0, we'll add some noise to this selection (produced by default by `initial_item`.
3.  Test Step.
    -   We'll record and score response patterns as normal.
    -   We'll use MLE for estimating ability
    -   For response patterns with 0 variance, we'll adjust the patterns with a factor of $\frac{1}{3\sqrt{n}}$ to avoid wild swings in ability estimate early in the cat.
4.  Stopping Step.
    -   The test will stop once:
        a.  the standard error of our ability estimate falls below a pre-defined cutoff.
        b.  the test reaches a certain length, to limit total testing time.

Now that we know how we will set up our simulation, let's make it happen.

## 1. Item Bank

Let's simulate a 3pl item bank using `generate_item_bank`.

```{r sim_bank}
# Number of items
n_items <- 500

# Set seed (for random params)
set.seed(015)

# Rasch, 1pl, 2pl, or 3pl
item_type = "3pl"

# Generate an item bank
item_bank <- generate_item_bank(n_items, model = item_type)
```

### 1.a. Visualize Item Bank

And let's visualize our item bank characteristics - IIFs, TIF, ICCs, and parameter distributions. Functions `item_info`, `item_info_bank`, and `item_ICC_bank` are used here.

```{r vis_bank, echo=FALSE}
# Visualize item info across the entire item bank
item_bank %>% 
  arrange(a, b) %>%
  item_info_bank(., range = c(-4,4)) %>% 
  mutate(item = as.factor(item)) %>%
  ggplot(., aes(x = thetas, y = info, group = item, color = item, fill = item)) +
    geom_line(alpha = 0.2, linewidth = .5) + 
    theme_clean() +
    theme(legend.position = "none") +
    labs(
      title = paste0("Item Information for ",item_type," Item Bank, ",n_items," items"),
      x = expression(theta),
      y = "Information"
    )

# Visualize bank info across the entire item bank
item_bank %>% 
  arrange(a, b) %>%
  item_info_bank(., range = c(-4,4)) %>% 
  group_by(thetas) %>%
  summarise(test_info = sum(info)) %>%
  ggplot(., aes(x = thetas, y = test_info)) +
    geom_line(alpha = 0.2, linewidth = 1) + 
    theme_clean() +
    labs(
      title = paste0("Test Information for ",item_type," Item Bank, ",n_items," items"),
      x = expression(theta),
      y = "Information"
    )

# Visualize ICC's across the entire item bank
item_bank %>% 
  arrange(a, b) %>%
  item_ICC_bank(., range = c(-4,4)) %>% 
  mutate(item = as.factor(item)) %>%
  ggplot(., aes(x = thetas, y = icc, group = item, color = item, fill = item)) +
    geom_line(alpha = 0.2, linewidth = .5) + 
    theme_clean() +
    theme(legend.position = "none") +
    labs(
      title = paste0("Item Characteristic Curves for ",item_type," Item Bank, ",n_items," items"),
      x = expression(theta),
      y = "P"
    )

# distribution of a parameters
item_bank %>%
  ggplot(., aes(x = a)) + 
  geom_density(alpha = 0.3, color = "green3", fill = "green3") +
  theme_clean() +
  labs(title = "Distribution of 'a' parameters")

# distribution of b parameters
item_bank %>%
  ggplot(., aes(x = b)) + 
  geom_density(alpha = 0.3, color = "blue3", fill = "blue3") +
  theme_clean() +
  labs(title = "Distribution of 'b' parameters")

# distribution of c parameters
item_bank %>%
  ggplot(., aes(x = c)) + 
  geom_density(alpha = 0.3, color = "purple3", fill = "purple3") +
  theme_clean() +
  labs(title = "Distribution of 'c' parameters")
```

## 2. Initial Step

Given no prior information about the test-taker, we'll select an initial item for administration using the `initial_item` function, given the `item_bank` dataframe we created earlier. The function calculates weights for each item based on the distance from the initial ability estimate. The returned data frame (which we'll save as `test_event`) includes placeholders for response data and the current ability estimate. See `?initial_item` for more information.

```{r step_initialize}
set.seed(123)
(test_event <- initial_item(item_bank_df = item_bank))
```

The first item selected is item_id = 383.

## 3. Test Step

### 3.1 Score the response, estimate ability, and update test_event table

Use the `score_reseponse` function to score this item. Let's assume we get the item **correct**.

```{r step_test}
(test_event <- score_response(
  test_event_df = test_event, 
  item_id = test_event$item_id[nrow(test_event)],  # Item ID
  response = 1                                     # 1 = Correct, 0 = Incorrect
  ))
```

Given that we got the item correct, our new ability estimate is 0.325, with a standard error of the estimate of 1.705. By default this score_response function uses the MLE kludge we mentioned earlier. If we didn't use that kludge, here's what the test_event table would look like:

```{r step_score}
(score_response(
  test_event_df = test_event, 
  item_id = test_event$item_id[nrow(test_event)],  # Item ID
  response = 1,                                    # 1 = Correct, 0 = Incorrect
  kludge = FALSE
  ))
```

An ability estimate of 3.89, with a SE of 9.93... Yes, let's use that kludge moving forward. Again it's only going to affect item selection until there is variance in the response pattern (someone with a *zero* score gets an item correct, or someone with a *perfect* score misses an item).

### 3.2 Check stopping criteria

Next, we'll check to see if our stopping criteria has been met. Since we haven't set stopping criteria, let's do that now.

-   Cap the number of items at 20
-   Set the standard error threshold to be 0.5 (stop if the value is less than 0.5)

Based on those, we'll use the `stop_test` function to evaluate our test_event table against our criteria.

-   `TRUE` means the criteria has been met; stop the test
-   `FALSE` means the criteria has not been met; continue the test

```{r step_stop}
stop_max_items <- 20
stop_min_se <- 0.5

stop_test(test_event_df = test_event,
          max_items = stop_max_items,
          min_se = stop_min_se)
```

Don't stop test. Keep moving.

### 3.3 Update the table of eligible items

```{r}
eligible_items <- update_eligible_items(eligible_items_df = item_bank, 
                                        test_event_df = test_event)

paste("Of",nrow(item_bank),"items in the bank,",nrow(eligible_items), "are eligible for selection.")
```

### 3.4 Select next item

The `next_item` function selects the item with the difficulty parameter closest to the test-taker's current ability estimate.

```{r step_nextitem}
set.seed(123)
(test_event <- next_item(eligible_items_df = eligible_items, 
                        test_event_df = test_event))
```

And at this point, we could just keep running this, changing our "answer" to 0 or 1, until the stopping criteria is met, and the test ends.

### Continue until stopping criteria are met

```{r step_loop}
# Answer to the current question
# 0 = Incorrect, 1 = Correct
answer <- 0

# Score response
test_event <- score_response(test_event_df = test_event, 
                             item_id = test_event[nrow(test_event),"item_id"], 
                             response = answer)
# Check Stopping Criteria
if(stop_test(test_event_df = test_event, 
             max_items = stop_max_items, 
             min_se = stop_min_se) == FALSE) {
  # If stopping criteria hasn't been met, update Eligible items
  eligible_items <- update_eligible_items(eligible_items_df = eligible_items, 
                                          test_event_df = test_event)
  # And select the next item.
  (test_event <- next_item(eligible_items_df = eligible_items, 
                           test_event_df = test_event))
} else {
  # If the stopping criteria has been met, end the test.
  print(test_event)
  "The test is complete!"
}
```

Yada yada yada, pretend we keep running this until the test stops.

# Basic CAT, Simulation

Now that we have our CAT working, let's set it up and simulate for a few hundred people to check how the CAT functions.

## 1. Item Bank

We'll use the same item bank as in our example: `item_bank`

## 2. Simulate CAT

Let's simulate our CAT for 500 people, using the same stopping criteria as before.

-   Max items = 20
-   Min SE = 0.50

```{r step_setup_sim}
# Number of test takers
n_people <- 500

# Define the seed outside of the function
seed = 123

# Stopping criteria, restated
stop_max_items <- 20
stop_min_se <- 0.5

# Create a set of ability estimates
sample_abilities <- rnorm(n_people, 
                          mean = 0, 
                          sd = 1)
```

When running this simulation, however, the consistency of responses will impact how the CAT performs. For instance, we could simulate every respondent ('sim') answering exactly as expected based on their actual ability ${\theta}$ and b-parameter of item j, $b_{i}$. So if $b_{i} < {\theta}$, answer correct; if ${\theta} < b_{i}$, answer incorrect. However this type of highly consistent responding is not typical, and instead, responses will have some degree of inconsistency.

To accommodate this in our simulation, the function `simulate_cat` includes an argument to vary the `response_consistency` when simulating responses. The function simulates responses by selecting a response from a binomial distribution of the `prob` function for a given ability and an item's a, b, and c parameters. The `response_consistency` value multiplies the 'a' parameter, making the probability density function steeper and therefore a selection from the binomial distribution will be more consistent with the sim's ability, ${\theta}$. The default `response_consistency` is set to 1, which doesn't impact the `prob` function, and setting this argument to values above 1 will result in more consistent responding, values between 0 and 1 will result in less consistent responding.

To demonstrate the difference in simulated response consistency, we'll run the simulation for two different `response_consistency` values: 1 and 5.

-   The first group (response_consistency = 1) will be the **Inconsistent** group.
-   The second group (response_consistency = 5) will be the **Consistent** group.

```{r sim groups}
# Run the simulation with less consistent responding
test_cat_consistency1 <- simulate_cat(item_bank = item_bank, 
                           abilities = sample_abilities, 
                           seed = seed, 
                           max_items = stop_max_items,
                           min_se = stop_min_se,
                           response_consistency = 1, 
                           silent = TRUE)

# Run the simulation with very consistent responding
test_cat_consistency5 <- simulate_cat(item_bank = item_bank, 
                           abilities = sample_abilities, 
                           seed = seed, 
                           max_items = stop_max_items,
                           min_se = stop_min_se,
                           response_consistency = 5,
                           silent = TRUE)
```

## 3. Review CAT Summary Statistics {.tabset}

### Inconsistent

```{r sim_summary1, echo=FALSE}
# Less Consistent Responses
test_cat_consistency1$summary %>%
  mutate(residual = ability - final_ability) %>%
  psych::describe() %>% as.data.frame %>%
  filter(vars !=1 ) %>% 
  select(-vars) %>%
  relocate(n, mean, median, sd, min, max)
```

### Consistent

```{r sim_summary2, echo=FALSE}
# Consistent Responses
test_cat_consistency5$summary %>%
  mutate(residual = ability - final_ability) %>%
  psych::describe() %>% as.data.frame %>%
  filter(vars !=1 ) %>% 
  select(-vars) %>%
  relocate(n, mean, median, sd, min, max)
```

Although the distribution of estimates are similar, the error associated with the inconsistent group is quite a bit larger. Let's

## 4. Visualizations

```{r sim_visfns, echo=FALSE}
# Create functions to replicate the visualizations for both groups 
# Label the colors
dat_label_color <- list("Consistent" = "green3",
                        "Inconsistent" = "red3")

# Ability by Ability Estimate
ability_plot <- function(dat, dat_label) {
  ggplot(dat, aes(x = ability, y = final_ability)) +
  geom_hline(yintercept = 0) +
  geom_point(alpha = 0.5, color = dat_label_color[dat_label][[1]], fill = dat_label_color[dat_label][[1]]) +
  theme_clean() +
  labs(title = paste("Actual Ability by Ability Estimates for the",dat_label,"group"),
       x = "Actual Ability",
       y = "Estimated Ability") +
    scale_x_continuous(limits = c(-5,5)) +
    scale_y_continuous(limits = c(-5,5)) 
}

# Residual of Ability Estimate
residual_ability_plot <- function(dat, dat_label) {
  dat %>%
    mutate(residual = ability - final_ability) %>%
  ggplot(., aes(x = ability, y = residual)) +
  geom_hline(yintercept = 0) +
  geom_point(alpha = 0.5, color = dat_label_color[dat_label][[1]], fill = dat_label_color[dat_label][[1]]) +
  theme_clean() +
  labs(title = paste("Residual Ability Estimate for the",dat_label,"group"),
       x = "Actual Ability",
       y = "Residual") +
    scale_x_continuous(limits = c(-5,5)) +
    scale_y_continuous(limits = c(-3,3)) 
}

# Density of ability estimates
density_ability <- function(dat, dat_label){
  ggplot(dat) +
    geom_density(aes(x = ability), alpha = 0.7, color = "grey", fill = "grey") +
    geom_density(aes(x = final_ability), alpha = 0.3, color = dat_label_color[dat_label][[1]], fill = dat_label_color[dat_label][[1]]) +    
      theme_clean() +
      labs(title = paste("Density of Ability Estimates for the",dat_label,"group"),
           x = "Ability",
           y = "Density") +
    scale_x_continuous(limits = c(-5,5)) +
    scale_y_continuous(limits = c(0, 0.5))
  }

# Test Length
bar_test_length <- function(dat, dat_label) {
  x_min <- min(dat$n_items)
  x_max <- max(dat$n_items)
    ggplot(dat, aes(x = n_items)) +
      geom_bar(alpha = 0.5, color = dat_label_color[dat_label][[1]], fill = dat_label_color[dat_label][[1]]) +
      theme_clean() +
      labs(title = paste("Distribution of Test Length for the",dat_label,"group"),
           x = "Number of Items",
           y = "Density") + 
      scale_x_continuous(limits = c(0,25)) +
      scale_y_continuous(limits = c(0,150))
}

# Info at Ability Estimate
info_ability_plot <- function(dat, dat_label) {
  ggplot(dat, aes(x = final_ability, y = test_info_at_final_ability)) +
  geom_hline(yintercept = 0) +
  geom_point(alpha = 0.5, color = dat_label_color[dat_label][[1]], fill = dat_label_color[dat_label][[1]]) +
  theme_clean() +
  labs(title = paste("Test Info at Final Ability Estimate for the",dat_label,"group"),
       x = "Final Ability (Theta)",
       y = "Test Information for Final Ability Estimate") +
    scale_x_continuous(limits = c(-5,5)) +
    scale_y_continuous(limits = c(0,5)) 
}
```

### Ability Plots {.tabset}

#### Inconsistent

```{r vis1.1, echo=FALSE}
ability_plot(test_cat_consistency1$summary, "Inconsistent")
```

#### Consistent

```{r vis1.2, echo=FALSE}
ability_plot(test_cat_consistency5$summary, "Consistent")
```

### Residual Plots {.tabset}

#### Inconsistent

```{r vis2.1, echo=FALSE}
residual_ability_plot(test_cat_consistency1$summary, "Inconsistent")
```

#### Consistent

```{r vis2.2, echo=FALSE}
residual_ability_plot(test_cat_consistency5$summary, "Consistent")
```

### Ability Density {.tabset}

#### Inconsistent

```{r vis3.1, echo=FALSE}
density_ability(test_cat_consistency1$summary, "Inconsistent")
```

Note: Density of actual abilities is in grey.

#### Consistent

```{r vis3.2, echo=FALSE}
density_ability(test_cat_consistency5$summary, "Consistent")
```

Note: Density of actual abilities is in grey.

### Test Length {.tabset}

#### Inconsistent

```{r vis4.1, echo=FALSE}
bar_test_length(test_cat_consistency1$summary, "Inconsistent")
```

#### Consistent

```{r vis4.2, echo=FALSE}
bar_test_length(test_cat_consistency5$summary, "Consistent")
```

### Information by Ability {.tabset}

#### Inconsistent

```{r vis5.1, echo=FALSE}
info_ability_plot(test_cat_consistency1$summary, "Inconsistent")
```

#### Consistent

```{r vis5.2, echo=FALSE}
info_ability_plot(test_cat_consistency5$summary, "Consistent")
```

### CAT Response Pattern and Ability Estimation Plots

And let's visualize the CAT response pattern and ability estimates for a few cases.

Since we used the same ability estimates in our simulations, and the only thing that changed between the two was response consistency, let's see how those affected how the CAT operated.

First, let's create a function to visualize these plots.
```{r vis_cat_fn}
# Function to create the CAT plot
cat_test_plot <- function(sim_cat, case_n, group_label = NULL) {
  case_ability <- sim_cat$summary$ability[sim_cat$summary$case == case_n]
  sim_cat$event %>%
    filter(case == case_n) %>%
    mutate(response_label = ifelse(response == 1, "Correct", "Incorrect"),
           ribbon_min = ifelse(current_ability - current_ability_se < -6,-6,current_ability - current_ability_se),
           ribbon_max = ifelse(current_ability + current_ability_se > 6, 6, current_ability + current_ability_se)) %>%
    ggplot(., aes(x = order)) +
    geom_ribbon(aes(x = order + .5, ymin = ribbon_min, ymax = ribbon_max), fill = "lightblue", alpha = 0.5) +
    geom_hline(yintercept = case_ability, color = "gray40") +
    geom_line(aes(x = order + .5, y = current_ability, group = 1), color = "black") +
    geom_point(aes(x = order + .5, y = current_ability), shape = 18, fill = "black", size = 4, stroke = 1) +
    geom_text(aes(x = order + .5, y = current_ability, label = sprintf("%.2f", current_ability)), vjust = -1, hjust = 0.5, color = "black", size = 3) +
    geom_line(aes(y = b, group = 1), linetype = "dotted") +
    geom_point(aes(y = b, fill = response_label), shape = 21, size = 4, stroke = 1) +
    scale_fill_manual(values = c("Correct" = "green3", "Incorrect" = "red3")) +
    labs(x = "Item Order", y = "Theta",
         title = "CAT Response Pattern and Ability Estimation Plot",
         subtitle = paste0("Case ", case_n, ", \u03B8 = ", round(case_ability, 3), ifelse(is.null(group_label),"",paste0(" // ", group_label)))) +
    scale_x_continuous(breaks = 1:50, labels = as.character(1:50)) +
    scale_y_continuous(limits = c(-6, 6)) +
    theme_clean() +
    theme(axis.text.x = element_text(color = "black", face = "bold", size = 10),
          axis.ticks.x = element_blank(),
          panel.grid.minor = element_blank(),
          legend.position = "none")  # Remove the legend
}
```

Let's pick the case with the ability closest to 0, case 7. We'll start with the **Consistent** group.

```{r vis_cat1.1}
cat_test_plot(test_cat_consistency5, 7, "Consistent Group")
```

These plot show a number of things related to this CAT administration:

-   The x-axis is the order of item administration, from 1 to $n$.
-   The y-axis represents the latent theta scale, on which b-parameters and ability estimates are located.
    -   Easier items and lower abilities are lower (more negative) on the Theta scale, harder items and higher ability are higher (more positive) on the scale.
-   Items are represented by the filled circles. In this case there are 12 circles, as the CAT stopped before item 13.
    -   Green fill indicates the item was answered correctly.
    -   Red fill indicates the item was answered incorrectly.
-   Ability estimates are depicted as black diamonds.
    -   They are offset to represent the step between item administrations in which ability is estimated. For instance, after item 1 is administered and answered correctly, the ability estimate of this sim is 0.60. Item 2 was slightly harder, which they answered incorrectly, and their ability was estimated to be -0.38. The final ability estimate here is 0.42.
-   The light blue band about the ability estimate is the standard error of the estimate.
-   The horizontal grey line represents the sim's actual ability. For highly consistent responding, we'd expect the sim to get all items *below* the line correct, and items *above* the line incorrect. This will be more evident in the next plots.

And here's the plot for the Inconsistent group

```{r vis_cat1.2}
cat_test_plot(test_cat_consistency1, 7, "Inconsistent Group")
```

Let's take a look at the CAT administrations for a few cases.

### CAT Response Plot: Case 18 {.tabset}

#### Inconsistent

```{r vis_cat2.1}
cat_test_plot(test_cat_consistency1, 18, "Inconsistent Group")
```

#### Consistent

```{r vis_cat2.2}
cat_test_plot(test_cat_consistency5, 18, "Consistent Group")
```

### CAT Response Plot: Case 2 {.tabset}

#### Inconsistent

```{r vis_cat3.1}
cat_test_plot(test_cat_consistency1, 2, "Inconsistent Group")
```

#### Consistent

```{r vis_cat3.2}
cat_test_plot(test_cat_consistency5, 2, "Consistent Group")
```

### CAT Response Plot: Case 3 {.tabset}

#### Inconsistent

```{r vis_cat4.1}
cat_test_plot(test_cat_consistency1, 3, "Inconsistent Group")
```

#### Consistent

```{r vis_cat4.2}
cat_test_plot(test_cat_consistency5, 3, "Consistent Group")
```

### Item Exposure
Finally, let's look at how our item selected functioned.

#### Exposure Bar Charts{.tabset}
##### Inconsistent
```{r item_exp1, echo=FALSE}
test_cat_consistency1$event %>%
  group_by(item_id) %>% 
  summarise(exposure = n()) %>%
  ggplot(., aes(x = exposure)) +
  geom_bar(alpha = .5, color = "red3", fill = "red3") +
  theme_clean() +
  scale_x_continuous(limits = c(0, 150)) +
  scale_y_continuous(limits = c(0, 50)) +
  labs(x = "Exposures", y = "Count of Items",
         title = "Item Exposure, Inconsistent Group")
```

Looks like there is one item that has about twice as many exposures as all the others. Let's see how exposure relates to the b-parameters.

##### Consistent
```{r item_exp2, echo=FALSE}
test_cat_consistency5$event %>%
  group_by(item_id) %>% 
  summarise(exposure = n()) %>%
  ggplot(., aes(x = exposure)) +
  geom_bar(alpha = .5, color = "green3", fill = "green3") +
  theme_clean() +
  scale_x_continuous(limits = c(0, 150)) +
  scale_y_continuous(limits = c(0, 50)) +
  labs(x = "Exposures", y = "Count of Items",
         title = "Item Exposure, Consistent Group")
```

Looks like there is one item that has about twice as many exposures as all the others. Let's see how exposure relates to the b-parameters.

#### Exposure by b-parameter
```{r item_b_plot, echo = FALSE}
test_cat_consistency1$event %>%
  group_by(item_id) %>% 
  summarise(exposure = n(),
            b = mean(b)) %>%
  mutate(Group = "Inconsistent") %>%
  bind_rows(
    test_cat_consistency5$event %>%
      group_by(item_id) %>% 
      summarise(exposure = n(),
                b = mean(b)) %>%
      mutate(Group = "Consistent")) %>%
  ggplot(., aes(x = b, y = exposure, color = Group)) +
  geom_point(alpha = 0.5) +
  theme_clean() +
  scale_y_continuous(limits = c(0, 150)) +
  scale_color_manual(values = c("Consistent" = "green3", "Inconsistent" = "red3")) +
  labs(x = "`b` parameter", y = "Exposure",
         title = "Item Exposure by 'b' parameter and Group")
  
```

That makes sense - the item with *likely* the b-parameter nearest 0 is selected by far most often. There are a few corrective actions we could take. For example, we could change the `next_item` function to select from a uniform distribution of items around the starting ability estimate (0), instead of a weighted distribution. Let's look at the other items with a lot of exposure.

```{r}
test_cat_consistency1$event %>%
  group_by(item_id) %>% 
  summarise(exposure = n(),
            b = mean(b)) %>%
  arrange(desc(exposure)) %>% head(n = 10)
```

Interestingly we have a few items with b-parameters beyond 0.5 logits from 0, which is the cutoff for initial item selection. That means these items are selected with great frequency beyond the first step. Additional investigation would be needed to understand how and why these items are selected over others nearby. 

# Summary

This document provided an overview of how a Computerized Adaptive Test works and demonstrated a simple CAT simulation. Key components covered include:

1.  Creating an item bank with IRT-calibrated parameters
2.  Implementing initial item selection strategies
3.  Estimating ability using Maximum Likelihood Estimation (MLE)
4.  Selecting subsequent items based on current ability estimates
5.  Applying stopping criteria to end the test

The document then simulated CAT administrations for 500 test-takers under two conditions: consistent and inconsistent responding. Visualizations were provided to compare the performance of the CAT under these conditions, including ability estimation accuracy, test length, and information at ability estimates. Overall, this simulation demonstrated how CATs can efficiently estimate test-taker abilities with fewer items than fixed-form tests, and showed the impact of response consistency on CAT performance. The concepts and code provided serve as a foundation for understanding and implementing basic CAT systems.
